# -*- coding: utf-8 -*-
"""TrabajoWebSemantica.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d0qWPnOLQbFzarGUwfjZ9WeiF-WvVF8N

# **Tarea 1/Opcinonal 1**: Transformar a RDF

## **Primer Conjunto de Datos (JSON):** "Cantidad de pasajeros embarcados por bloque horario en el Aeropuerto de Punta Arenas Presidente Carlos IbÃ¡Ã±ez del Campo"

## Script, GeneraciÃ³n en formato RDF, archivo ttl
"""

!pip install rdflib

import json
import rdflib
from rdflib import Graph, Namespace, URIRef, Literal
from rdflib.namespace import RDF, XSD
from google.colab import files

# Ruta del archivo JSON en Google Colab
json_filepath = "/content/sample_data/PasajerosembarcadosporhoraenelAeropuertoSCCI_2818101738163526694.json"

# Leer el archivo JSON
with open(json_filepath, "r", encoding="utf-8") as file:
    data = json.load(file)

# Extraer encabezados y datos
headers = data[0]  # Primera fila contiene los nombres de las columnas
rows = data[1:]    # Filas de datos

# Crear un grafo RDF
g = Graph()

# Definir un namespace personalizado
EX = Namespace("http://example.org/airport#")
g.bind("ex", EX)

# FunciÃ³n para convertir fecha de 'DD-MM-YYYY' a 'YYYY-MM-DD'
def convertir_fecha(fecha_str):
    partes = fecha_str.split("-")  # Separar por guion
    return f"{partes[2]}-{partes[1]}-{partes[0]}"  # Reordenar como YYYY-MM-DD

# Iterar sobre los datos y agregarlos al grafo
for i, row in enumerate(rows):
    registro_uri = URIRef(EX[f"registro_{i}"])

    # Agregar tipo de entidad
    g.add((registro_uri, RDF.type, EX.RegistroEmbarque))

    # Convertir fecha al formato correcto
    fecha_iso = convertir_fecha(row[0])

    # Agregar propiedades con tipos de datos adecuados
    g.add((registro_uri, EX.fecha, Literal(fecha_iso, datatype=XSD.date)))  # Fecha corregida
    g.add((registro_uri, EX.aÃ±o, Literal(int(row[1]), datatype=XSD.integer)))
    g.add((registro_uri, EX.mes, Literal(int(row[2]), datatype=XSD.integer)))
    g.add((registro_uri, EX.dia, Literal(int(row[3]), datatype=XSD.integer)))
    g.add((registro_uri, EX.bloqueHorario, Literal(int(row[4]), datatype=XSD.integer)))
    g.add((registro_uri, EX.ruta, Literal(row[5], datatype=XSD.string)))
    g.add((registro_uri, EX.cantidadPasajeros, Literal(int(row[6]), datatype=XSD.integer)))

# Guardar el grafo en formato Turtle
rdf_filename = "embarques_aeropuerto.ttl"
g.serialize(destination=rdf_filename, format="turtle")

# Descargar el archivo generado
files.download(rdf_filename)

print(f"Archivo RDF '{rdf_filename}' generado y listo para descargar.")

"""## **Segundo Conjunto de Datos (XLSX):**"VehÃ­culos registrados en el Registro Civil por medio del Registro de VehÃ­culos Motorizados."

## Script, GeneraciÃ³n en formato RDF, archivo ttl
"""

# ğŸ“ Instalar dependencias necesarias
!pip install rdflib pandas openpyxl

import pandas as pd
import rdflib
from rdflib import Graph, Namespace, URIRef, Literal
from rdflib.namespace import RDF, XSD
from google.colab import files

# ğŸ“Œ Ruta del archivo XLSX en Google Colab
xlsx_filepath = "/content/sample_data/C026Inscripciondevehiculos_2927501738358921050.xlsx"

# ğŸ“Œ Cargar el archivo Excel en un DataFrame de Pandas
df = pd.read_excel(xlsx_filepath)

# ğŸ“Œ Crear un grafo RDF
g = Graph()

# ğŸ“Œ Definir un namespace personalizado
EX = Namespace("http://example.org/vehicles#")
g.bind("ex", EX)

# ğŸ“Œ Convertir el DataFrame a RDF
for i, row in df.iterrows():
    registro_uri = URIRef(EX[f"registro_{i}"])

    # Agregar tipo de entidad
    g.add((registro_uri, RDF.type, EX.InscripcionVehiculo))

    # Iterar sobre las columnas y agregar propiedades al grafo
    for col in df.columns:
        valor = row[col]
        if pd.notna(valor):  # Verifica que no sea NaN
            prop_uri = URIRef(EX[col.replace(" ", "_")])  # Convertir espacios en _

            # Definir tipo de datos RDF
            if isinstance(valor, int):
                g.add((registro_uri, prop_uri, Literal(valor, datatype=XSD.integer)))
            elif isinstance(valor, float):
                g.add((registro_uri, prop_uri, Literal(valor, datatype=XSD.decimal)))
            else:
                g.add((registro_uri, prop_uri, Literal(str(valor), datatype=XSD.string)))

# ğŸ“Œ Guardar el grafo en formato Turtle
rdf_filename = "inscripcion_vehiculos.ttl"
g.serialize(destination=rdf_filename, format="turtle")

# ğŸ“Œ Descargar el archivo generado
files.download(rdf_filename)

print(f"âœ… Archivo RDF '{rdf_filename}' generado y listo para descargar.")

"""# **Tarea 2/Opcional 2**: Consultas SPARQL. Datos en Memoria

## **Primer Conjunto de Datos (JSON):** "Cantidad de pasajeros embarcados por bloque horario en el Aeropuerto de Punta Arenas Presidente Carlos IbÃ¡Ã±ez del Campo"

* Consulta 1: Registros de embarque del 20 de abril de 2019
* Consulta 2: Cantidad total de pasajeros embarcados en abril
* Consulta 3: Registros con mÃ¡s de 200 pasajeros embarcados
* Consulta 4: Cantidad de vuelos nacionales vs. internacionales
"""

import rdflib
from rdflib import Graph, Namespace
from rdflib.plugins.sparql import prepareQuery
import pandas as pd

# ğŸ“ Ruta del archivo RDF almacenado en Google Colab
rdf_filepath = "/content/embarques_aeropuerto.ttl"

# ğŸ“ Crear un grafo RDF y cargar los datos desde el archivo Turtle
g = Graph()
g.parse(rdf_filepath, format="turtle")

# ğŸ“ Definir el namespace
EX = Namespace("http://example.org/airport#")

# ğŸ” **Consulta 1: Registros de embarque del 20 de abril de 2019**
query_1 = prepareQuery("""
    SELECT ?registro ?fecha ?cantidadPasajeros WHERE {
        ?registro a ex:RegistroEmbarque ;
                  ex:fecha "2019-04-20"^^xsd:date ;
                  ex:cantidadPasajeros ?cantidadPasajeros .
    }
""", initNs={"ex": EX})

# ğŸ” **Consulta 2: Cantidad total de pasajeros embarcados en abril**
query_2 = prepareQuery("""
    SELECT ?mes (SUM(?cantidadPasajeros) AS ?totalPasajeros) WHERE {
        ?registro a ex:RegistroEmbarque ;
                  ex:mes ?mes ;
                  ex:cantidadPasajeros ?cantidadPasajeros .
        FILTER(?mes = 4)
    }
    GROUP BY ?mes
""", initNs={"ex": EX})

# ğŸ” **Consulta 3: Registros con mÃ¡s de 200 pasajeros embarcados**
query_3 = prepareQuery("""
    SELECT ?registro ?fecha ?cantidadPasajeros WHERE {
        ?registro a ex:RegistroEmbarque ;
                  ex:fecha ?fecha ;
                  ex:cantidadPasajeros ?cantidadPasajeros .
        FILTER(?cantidadPasajeros > 200)
    }
    ORDER BY DESC(?cantidadPasajeros)
""", initNs={"ex": EX})

# ğŸ” **Consulta 4: Cantidad de vuelos nacionales vs. internacionales**
query_4 = prepareQuery("""
    SELECT ?ruta (COUNT(?registro) AS ?totalVuelos) WHERE {
        ?registro a ex:RegistroEmbarque ;
                  ex:ruta ?ruta .
    }
    GROUP BY ?ruta
""", initNs={"ex": EX})

# ğŸ“ **Ejecutar consultas**
results_1 = list(g.query(query_1))
results_2 = list(g.query(query_2))
results_3 = list(g.query(query_3))
results_4 = list(g.query(query_4))

# ğŸ“ **Crear DataFrames para visualizar los resultados**
df_1 = pd.DataFrame(results_1, columns=["Registro", "Fecha", "Cantidad Pasajeros"])
df_2 = pd.DataFrame(results_2, columns=["Mes", "Total Pasajeros"])
df_3 = pd.DataFrame(results_3, columns=["Registro", "Fecha", "Cantidad Pasajeros"])
df_4 = pd.DataFrame(results_4, columns=["Ruta", "Total Vuelos"])

# ğŸ“ **Mostrar resultados**
print("\nğŸ“Œ Registros de embarque del 20 de abril de 2019:")
print(df_1.head())

print("\nğŸ“Œ Cantidad total de pasajeros embarcados en abril:")
print(df_2.head())

print("\nğŸ“Œ Registros de embarque con mÃ¡s de 200 pasajeros:")
print(df_3.head())

print("\nğŸ“Œ Cantidad de vuelos nacionales e internacionales:")
print(df_4.head())

"""## **Segundo Conjunto de Datos (XML):**"VehÃ­culos registrados en el Registro Civil por medio del Registro de VehÃ­culos Motorizados, esta informaciÃ³n es consolidad y disponibilizada por ANAC A.G"

* Â¿CuÃ¡les son los tipos de vehÃ­culos que mÃ¡s se venden en enero?
* Â¿CuÃ¡l es el tipo de vehÃ­culo que mÃ¡s se vende en general?
* Â¿CuÃ¡l es el tipo de vehÃ­culo que mÃ¡s se vendiÃ³ en 2020?
* Â¿CuÃ¡ntos tipos diferentes de vehÃ­culos hay?
"""

# ğŸ“ Instalar rdflib y pandas si no estÃ¡n instalados
!pip install rdflib pandas

import rdflib
import pandas as pd
from rdflib import Graph

# ğŸ“Œ Ruta del archivo RDF en formato Turtle
rdf_filepath = "/content/inscripcion_vehiculos.ttl"

# ğŸ“Œ Cargar el archivo RDF en un grafo
g = Graph()
g.parse(rdf_filepath, format="turtle")

# ğŸ“Œ FunciÃ³n para ejecutar consultas SPARQL y mostrar resultados
def ejecutar_consulta(sparql_query, descripcion):
    print(f"\nğŸ”¹ {descripcion}\n")
    qres = g.query(sparql_query)

    # Convertir resultados en DataFrame para mejor visualizaciÃ³n
    resultados = []
    for row in qres:
        resultados.append([str(valor) for valor in row])

    if resultados:
        df = pd.DataFrame(resultados, columns=[str(var) for var in qres.vars])
        from google.colab import data_table
        display(df)  # ğŸ“Œ Muestra la tabla en Colab
    else:
        print("âš ï¸ No se encontraron resultados.")

# ğŸ“Œ Consultas SPARQL corregidas:

# 1ï¸âƒ£ Â¿CuÃ¡les son los tipos de vehÃ­culos que mÃ¡s se venden en enero?
consulta1 = """
PREFIX ex: <http://example.org/vehicles#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?tipo (SUM(?total_cantidad) AS ?total_vendidos)
WHERE {
  ?vehiculo ex:mes "Enero"^^xsd:string ;
            ex:tipo ?tipo ;
            ex:total_cantidad ?total_cantidad .
}
GROUP BY ?tipo
ORDER BY DESC(?total_vendidos)
"""
ejecutar_consulta(consulta1, "ğŸ“Œ Tipos de vehÃ­culos mÃ¡s vendidos en Enero")

# 2ï¸âƒ£ Â¿CuÃ¡l es el tipo de vehÃ­culo que mÃ¡s se vende en general?
consulta2 = """
PREFIX ex: <http://example.org/vehicles#>

SELECT ?tipo (SUM(?total_cantidad) AS ?total_vendidos)
WHERE {
  ?vehiculo ex:tipo ?tipo ;
            ex:total_cantidad ?total_cantidad .
}
GROUP BY ?tipo
ORDER BY DESC(?total_vendidos)
LIMIT 1
"""
ejecutar_consulta(consulta2, "ğŸ“Œ Tipo de vehÃ­culo mÃ¡s vendido")

# 3ï¸âƒ£ Â¿CuÃ¡l es el tipo de vehÃ­culo que mÃ¡s se vendiÃ³ en 2020?
consulta3 = """
PREFIX ex: <http://example.org/vehicles#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT ?tipo (SUM(?total_cantidad) AS ?total_vendidos)
WHERE {
  ?vehiculo ex:anio 2020 ;
            ex:tipo ?tipo ;
            ex:total_cantidad ?total_cantidad .
}
GROUP BY ?tipo
ORDER BY DESC(?total_vendidos)
LIMIT 1
"""
ejecutar_consulta(consulta3, "ğŸ“Œ Tipo de vehÃ­culo mÃ¡s vendido en 2020")

# 4ï¸âƒ£ Â¿CuÃ¡ntos tipos diferentes de vehÃ­culos hay?
consulta4 = """
PREFIX ex: <http://example.org/vehicles#>

SELECT (COUNT(DISTINCT ?tipo) AS ?total_tipos)
WHERE {
  ?vehiculo ex:tipo ?tipo .
}
"""
ejecutar_consulta(consulta4, "ğŸ“Œ Cantidad de tipos diferentes de vehÃ­culos")

"""# **Tarea 3/Opcional 3:**  Crear un modelo de datos en Shape Expressions (ShEx) y  SHACL que permita validar los datos. Compararlos

## **Primer Conjunto de Datos (JSON):** "Cantidad de pasajeros embarcados por bloque horario en el Aeropuerto de Punta Arenas Presidente Carlos IbÃ¡Ã±ez del Campo"

### SHACL
"""

# ğŸ“ Instalar pyshacl si no estÃ¡ instalado
!pip install pyshacl rdflib

import rdflib
from pyshacl import validate
import logging

# ğŸ“ Desactivar todos los mensajes excepto errores
logging.getLogger("pyshacl").setLevel(logging.ERROR)
logging.getLogger("rdflib").setLevel(logging.ERROR)

# ğŸ“ Cargar datos RDF
rdf_filepath = "/content/embarques_aeropuerto.ttl"
rdf_graph = rdflib.Graph()
rdf_graph.parse(rdf_filepath, format="turtle")

# ğŸ“ Definir el modelo SHACL
shacl_ttl = """
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix ex: <http://example.org/airport#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:RegistroEmbarqueShape
    a sh:NodeShape ;
    sh:targetClass ex:RegistroEmbarque ;

    # ğŸ“ RestricciÃ³n para "fecha"
    sh:property [
        sh:path ex:fecha ;
        sh:datatype xsd:date ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:description "La fecha del embarque debe estar en formato YYYY-MM-DD."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "aÃ±o"
    sh:property [
        sh:path ex:aÃ±o ;
        sh:datatype xsd:integer ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:minInclusive 1900 ;
        sh:maxInclusive 2100 ;
        sh:description "El aÃ±o debe ser un nÃºmero entero entre 1900 y 2100."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "mes"
    sh:property [
        sh:path ex:mes ;
        sh:datatype xsd:integer ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:minInclusive 1 ;
        sh:maxInclusive 12 ;
        sh:description "El mes debe ser un nÃºmero entero entre 1 y 12."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "dÃ­a"
    sh:property [
        sh:path ex:dia ;
        sh:datatype xsd:integer ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:minInclusive 1 ;
        sh:maxInclusive 31 ;
        sh:description "El dÃ­a debe ser un nÃºmero entero entre 1 y 31."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "bloqueHorario"
    sh:property [
        sh:path ex:bloqueHorario ;
        sh:datatype xsd:integer ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:minInclusive 0 ;
        sh:maxInclusive 23 ;
        sh:description "El bloque horario debe ser un nÃºmero entero entre 0 y 23."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "ruta"
    sh:property [
        sh:path ex:ruta ;
        sh:datatype xsd:string ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:in ( "NACIONAL"^^xsd:string "INTERNACIONAL"^^xsd:string ) ;
        sh:description "La ruta del embarque debe ser 'NACIONAL' o 'INTERNACIONAL'."@es ;
    ] ;

    # ğŸ“ RestricciÃ³n para "cantidadPasajeros"
    sh:property [
        sh:path ex:cantidadPasajeros ;
        sh:datatype xsd:integer ;
        sh:minCount 1 ;
        sh:maxCount 1 ;
        sh:minInclusive 0 ;
        sh:description "La cantidad de pasajeros debe ser un nÃºmero entero 0 o mayor."@es ;
    ] .
"""

# ğŸ“ Cargar el modelo SHACL en un grafo
shacl_graph = rdflib.Graph()
shacl_graph.parse(data=shacl_ttl, format="turtle")

# ğŸ“ Validar solo los primeros 10 registros
print("\nğŸ“Œ Iniciando validaciÃ³n de los primeros 10 registros...\n")

count_valid = 0
count_invalid = 0

for i, registro in enumerate(rdf_graph.subjects(rdflib.RDF.type, rdflib.URIRef("http://example.org/airport#RegistroEmbarque"))):

    # Crear un subgrafo RDF con solo este registro
    registro_graph = rdflib.Graph()

    # Agregar las triples de este registro al subgrafo
    for triple in rdf_graph.triples((registro, None, None)):
        registro_graph.add(triple)

    # Ejecutar la validaciÃ³n SHACL solo para este registro
    conforms, results_graph, results_text = validate(registro_graph, shacl_graph=shacl_graph, inference="rdfs")

    # ğŸ“ Mostrar resultado de la validaciÃ³n para cada registro
    if conforms:
        print(f"âœ… Registro {i+1}: VÃLIDO â†’ {registro}")
        count_valid += 1
    else:
        print(f"âŒ Registro {i+1}: INVÃLIDO â†’ {registro}")
        print("   ğŸ”¹ Detalles del error:")
        print(results_text)
        count_invalid += 1

    # ğŸ“ Limitar la validaciÃ³n a 10 registros para evitar demoras
    if i >= 9:
        print("\nâš ï¸ Se han validado 10 registros como muestra. Deteniendo validaciÃ³n para optimizar tiempo.\n")
        break

# ğŸ“ Resumen final de la validaciÃ³n
print("\nğŸ“Œ Resumen de la validaciÃ³n:")
print(f"âœ… Registros vÃ¡lidos: {count_valid}")
print(f"âŒ Registros invÃ¡lidos: {count_invalid}")

"""### ShEx"""

# ğŸ“ Instalar pyshex si no estÃ¡ instalado
!pip install pyshex rdflib

import rdflib
from pyshex import ShExEvaluator
import logging

# ğŸ“ Desactivar mensajes de debug y warnings
logging.getLogger("rdflib").setLevel(logging.ERROR)
logging.getLogger("pyshex").setLevel(logging.ERROR)

# ğŸ“ Definir el modelo ShEx corregido (PERMITIENDO cantidadPasajeros = 0)
shex_schema = """
PREFIX ex: <http://example.org/airport#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

start = @ex:RegistroEmbarqueShape  # ğŸ”¹ Asegura que inicie con esta forma

ex:RegistroEmbarqueShape {
    ex:fecha xsd:date ;   # Fecha en formato YYYY-MM-DD
    ex:aÃ±o xsd:integer MinInclusive 1900 MaxInclusive 2100 ;  # AÃ±o entre 1900 y 2100
    ex:mes xsd:integer MinInclusive 1 MaxInclusive 12 ;  # Mes entre 1 y 12
    ex:dia xsd:integer MinInclusive 1 MaxInclusive 31 ;  # DÃ­a entre 1 y 31
    ex:bloqueHorario xsd:integer MinInclusive 0 MaxInclusive 23 ;  # Horas entre 0 y 23
    ex:cantidadPasajeros xsd:integer MinInclusive 0  # âš ï¸ Ahora acepta 0 pasajeros
}
"""

# ğŸ“ Cargar los datos RDF
rdf_filepath = "/content/embarques_aeropuerto.ttl"
rdf_graph = rdflib.Graph()
rdf_graph.parse(rdf_filepath, format="turtle")

# ğŸ“ Mostrar el contenido del primer registro RDF para diagnÃ³stico
print("\nğŸ“Œ Primer registro RDF detectado:\n")
for s in rdf_graph.subjects(rdflib.RDF.type, rdflib.URIRef("http://example.org/airport#RegistroEmbarque")):
    print(f"Registro: {s}")

    # Imprimir todas las propiedades de este registro
    for p, o in rdf_graph.predicate_objects(subject=s):
        print(f"   ğŸ”¹ {p} â†’ {o}")

    break  # Solo mostramos el primer registro

# ğŸ“ Inicializar el validador ShEx con el esquema corregido
evaluator = ShExEvaluator(rdf_graph, shex_schema)

# ğŸ“ Validar solo los primeros 10 registros
print("\nğŸ“Œ Iniciando validaciÃ³n con ShEx de los primeros 10 registros...\n")

count_valid = 0
count_invalid = 0

for i, registro in enumerate(rdf_graph.subjects(rdflib.RDF.type, rdflib.URIRef("http://example.org/airport#RegistroEmbarque"))):

    # ğŸ“ Evaluar este registro con ShEx
    results = evaluator.evaluate(focus=str(registro))

    # ğŸ“ Mostrar resultado de la validaciÃ³n para cada registro
    if results[0].result:
        print(f"âœ… Registro {i+1}: VÃLIDO â†’ {registro}")
        count_valid += 1
    else:
        print(f"\nâŒ Registro {i+1}: INVÃLIDO â†’ {registro}")
        for r in results:
            print(f"ğŸ”¹ Nodo evaluado: {r.focus}")
            print(f"ğŸ”¹ Mensaje de error: {r.reason}")
        count_invalid += 1

    # ğŸ“ Limitar la validaciÃ³n a 10 registros
    if i >= 9:
        print("\nâš ï¸ Se han validado 10 registros como muestra. Deteniendo validaciÃ³n para optimizar tiempo.\n")
        break

# ğŸ“ Resumen final de la validaciÃ³n
print("\nğŸ“Œ Resumen de la validaciÃ³n:")
print(f"âœ… Registros vÃ¡lidos: {count_valid}")
print(f"âŒ Registros invÃ¡lidos: {count_invalid}")

"""## **Segundo Conjunto de Datos (XML):**"VehÃ­culos registrados en el Registro Civil por medio del Registro de VehÃ­culos Motorizados, esta informaciÃ³n es consolidad y disponibilizada por ANAC A.G"

### SHACL
"""

# ğŸ“ Instalar dependencias necesarias
!pip install pyshacl rdflib

import rdflib
from pyshacl import validate
import logging

# ğŸ“ Desactivar logs innecesarios
logging.getLogger("pyshacl").setLevel(logging.ERROR)
logging.getLogger("rdflib").setLevel(logging.ERROR)

# ğŸ“ Cargar los datos RDF
rdf_filepath = "/content/inscripcion_vehiculos.ttl"
rdf_graph = rdflib.Graph()
rdf_graph.parse(rdf_filepath, format="turtle")

# ğŸ“ Definir el modelo SHACL
shacl_ttl = """
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix ex: <http://example.org/vehicles#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:InscripcionVehiculoShape
    a sh:NodeShape ;
    sh:targetClass ex:InscripcionVehiculo ;

    sh:property [
        sh:path ex:anio ;
        sh:datatype xsd:integer ;
        sh:minInclusive 1900 ;
        sh:maxInclusive 2100 ;
    ] ;

    sh:property [
        sh:path ex:mes ;
        sh:datatype xsd:string ;
    ] ;

    sh:property [
        sh:path ex:tipo ;
        sh:datatype xsd:string ;
    ] ;

    sh:property [
        sh:path ex:total_cantidad ;
        sh:datatype xsd:integer ;
        sh:minInclusive 0 ;
    ] .
"""

# ğŸ“ Cargar el modelo SHACL
shacl_graph = rdflib.Graph()
shacl_graph.parse(data=shacl_ttl, format="turtle")

# ğŸ“ Validar solo los primeros 10 registros
print("\nğŸ“Œ Iniciando validaciÃ³n SHACL de los primeros 10 registros...\n")

count_valid = 0
count_invalid = 0

for i, registro in enumerate(rdf_graph.subjects(rdflib.RDF.type, rdflib.URIRef("http://example.org/vehicles#InscripcionVehiculo"))):

    if i >= 10:  # ğŸ“Œ Limita la validaciÃ³n a 10 registros
        break

    # Crear un subgrafo RDF con solo este registro
    registro_graph = rdflib.Graph()
    for triple in rdf_graph.triples((registro, None, None)):
        registro_graph.add(triple)

    # Ejecutar la validaciÃ³n SHACL solo para este registro
    conforms, results_graph, results_text = validate(registro_graph, shacl_graph=shacl_graph, inference="rdfs")

    # ğŸ“ Mostrar resultado de la validaciÃ³n para cada registro
    print(f"\nğŸ”¹ Validando registro {i+1}: {registro}")
    if conforms:
        print(f"âœ… Registro {i+1}: VÃLIDO")
        count_valid += 1
    else:
        print(f"âŒ Registro {i+1}: INVÃLIDO")
        print("   ğŸ”¹ Detalles del error:\n", results_text)
        count_invalid += 1

# ğŸ“ Resumen final de la validaciÃ³n
print("\nğŸ“Œ Resumen de la validaciÃ³n SHACL:")
print(f"âœ… Registros vÃ¡lidos: {count_valid}")
print(f"âŒ Registros invÃ¡lidos: {count_invalid}")

"""### ShEX"""

# ğŸ“ Instalar dependencias necesarias
!pip install pyshex rdflib

import rdflib
from pyshex import ShExEvaluator
import logging

# ğŸ“ Desactivar logs innecesarios
logging.getLogger("rdflib").setLevel(logging.ERROR)
logging.getLogger("pyshex").setLevel(logging.ERROR)

# ğŸ“ Definir el modelo ShEx
shex_schema = """
PREFIX ex: <http://example.org/vehicles#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>

start = @ex:InscripcionVehiculoShape

ex:InscripcionVehiculoShape {
    ex:anio xsd:integer MinInclusive 1900 MaxInclusive 2100 ;
    ex:mes xsd:string ;
    ex:tipo xsd:string ;
    ex:total_cantidad xsd:integer MinInclusive 0 ;
}
"""

# ğŸ“ Cargar los datos RDF
rdf_filepath = "/content/inscripcion_vehiculos.ttl"
rdf_graph = rdflib.Graph()
rdf_graph.parse(rdf_filepath, format="turtle")

# ğŸ“ Inicializar el validador ShEx con el esquema
evaluator = ShExEvaluator(rdf_graph, shex_schema)

# ğŸ“ Validar solo los primeros 10 registros
print("\nğŸ“Œ Iniciando validaciÃ³n con ShEx de los primeros 10 registros...\n")

count_valid = 0
count_invalid = 0

for i, registro in enumerate(rdf_graph.subjects(rdflib.RDF.type, rdflib.URIRef("http://example.org/vehicles#InscripcionVehiculo"))):

    if i >= 10:  # ğŸ“Œ Limita la validaciÃ³n a 10 registros
        break

    # ğŸ“ Evaluar este registro con ShEx
    results = evaluator.evaluate(focus=str(registro))

    # ğŸ“ Mostrar resultado de la validaciÃ³n para cada registro
    print(f"\nğŸ”¹ Validando registro {i+1}: {registro}")
    if results[0].result:
        print(f"âœ… Registro {i+1}: VÃLIDO")
        count_valid += 1
    else:
        print(f"âŒ Registro {i+1}: INVÃLIDO")
        for r in results:
            print(f"   ğŸ”¹ Nodo evaluado: {r.focus}")
            print(f"   ğŸ”¹ Mensaje de error: {r.reason}")
        count_invalid += 1

# ğŸ“ Resumen final de la validaciÃ³n
print("\nğŸ“Œ Resumen de la validaciÃ³n ShEx:")
print(f"âœ… Registros vÃ¡lidos: {count_valid}")
print(f"âŒ Registros invÃ¡lidos: {count_invalid}")

"""## **ComparaciÃ³n entre SHACL y ShEx en la validaciÃ³n de datos RDF**

1. PropÃ³sito y Enfoque
SHACL es mÃ¡s flexible y poderoso, pero mÃ¡s verboso.
ShEx es mÃ¡s sencillo y directo, ideal para validaciones rÃ¡pidas.

2. Sintaxis y Facilidad de Uso
ShEx es mÃ¡s fÃ¡cil de leer y escribir, pero menos flexible.
SHACL es mÃ¡s detallado y robusto, ideal para reglas avanzadas.

3. Expresividad y ValidaciÃ³n
SHACL es mÃ¡s poderoso para definir reglas complejas.
ShEx es mÃ¡s simple y fÃ¡cil de aplicar, pero menos expresivo.

4. Rendimiento y Escalabilidad
SHACL es mejor para bases de datos grandes.
ShEx es mÃ¡s rÃ¡pido en validaciones sencillas.

5. Aplicaciones y Casos de Uso
SHACL es ideal para entornos empresariales y validaciones complejas.
ShEx es mÃ¡s Ãºtil en validaciones rÃ¡pidas y validaciones estructurales simples.

# **Tarea 4/Opcional 4:** Comparativa entre RDF con SPARQL, Wikidata y LLMs.

Compararemos las respuestas obtenidas de diferentes fuentes de datos sobre inscripciÃ³n de vehÃ­culos. Se evaluarÃ¡ la calidad de las respuestas obtenidas desde:

* RDF + SPARQL (Datos estructurados en un grafo RDF con
 consultas SPARQL)
* Wikidata (Base de conocimiento colaborativa con consultas SPARQL)
* Large Language Models (LLMs) como GPT-4 (GeneraciÃ³n de respuestas basadas en aprendizaje profundo)

# **1. ComparaciÃ³n de respuestas entre RDF + SPARQL, Wikidata y LLMs**

Elegimos las siguientes preguntas para la comparaciÃ³n:

* Pregunta 1: Â¿CuÃ¡l fue el tipo de vehÃ­culo mÃ¡s vendido en 2020?
* Pregunta 2: Â¿CuÃ¡ntos tipos diferentes de vehÃ­culos se registraron en el dataset?

# **Respuesta mediante RDF + SPARQL (sobre nuestros datos)**
"""

# ğŸ“ Instalar rdflib y pandas si no estÃ¡n instalados
!pip install rdflib pandas

import rdflib
import pandas as pd

# ğŸ“Œ Cargar el archivo RDF
rdf_filepath = "/content/inscripcion_vehiculos.ttl"  # ğŸ“Œ Ruta del archivo RDF
g = rdflib.Graph()
g.parse(rdf_filepath, format="turtle")

# ğŸ“Œ FunciÃ³n para ejecutar consultas SPARQL y mostrar resultados
def ejecutar_consulta(sparql_query, titulo):
    print(f"\nğŸ”¹ {titulo}\n")
    qres = g.query(sparql_query)

    # Convertir resultados en DataFrame
    resultados = []
    for row in qres:
        resultados.append([str(valor) for valor in row])

    if resultados:
        df = pd.DataFrame(resultados, columns=[str(var) for var in qres.vars])
        display(df)  # ğŸ“Œ Muestra la tabla en Colab
    else:
        print("âš ï¸ No se encontraron resultados.")

# ğŸ“Œ Pregunta 1: Â¿CuÃ¡l fue el tipo de vehÃ­culo mÃ¡s vendido en 2020?
consulta1 = """
PREFIX ex: <http://example.org/vehicles#>

SELECT ?tipo (SUM(xsd:integer(?total_cantidad)) AS ?total_vendidos)
WHERE {
  ?vehiculo ex:anio 2020 ;
            ex:tipo ?tipo ;
            ex:total_cantidad ?total_cantidad .
}
GROUP BY ?tipo
ORDER BY DESC(?total_vendidos)
LIMIT 1
"""
ejecutar_consulta(consulta1, "ğŸ“Œ Tipo de vehÃ­culo mÃ¡s vendido en 2020")

# ğŸ“Œ Pregunta 2: Â¿CuÃ¡ntos tipos diferentes de vehÃ­culos se registraron en el dataset?
consulta2 = """
PREFIX ex: <http://example.org/vehicles#>

SELECT (COUNT(DISTINCT ?tipo) AS ?total_tipos)
WHERE {
  ?vehiculo ex:tipo ?tipo .
}
"""
ejecutar_consulta(consulta2, "ğŸ“Œ Cantidad de tipos diferentes de vehÃ­culos registrados")

"""# **Fortalezas de RDF + SPARQL:**
* Consultas exactas y estructuradas
* Alta precisiÃ³n en los resultados
* Datos completamente verificables y auditable

# **Desventajas de RDF + SPARQL:**
* Requiere conocimiento tÃ©cnico en SPARQL
* No es accesible para usuarios sin experiencia en bases de datos

# **Respuesta mediante Wikidata**
"""

# ğŸ“ Instalar librerÃ­as necesarias
!pip install SPARQLWrapper pandas

from SPARQLWrapper import SPARQLWrapper, JSON
import pandas as pd

# ğŸ“Œ Configurar el endpoint de Wikidata
endpoint_url = "https://query.wikidata.org/sparql"

# ğŸ“Œ FunciÃ³n para ejecutar consultas SPARQL en Wikidata
def ejecutar_consulta_wikidata(sparql_query, titulo):
    print(f"\nğŸ”¹ {titulo}\n")
    sparql = SPARQLWrapper(endpoint_url)
    sparql.setQuery(sparql_query)
    sparql.setReturnFormat(JSON)
    results = sparql.query().convert()

    # Convertir los resultados a un DataFrame
    datos = []
    for result in results["results"]["bindings"]:
        fila = {var: result[var]["value"] for var in result}
        datos.append(fila)

    if datos:
        df = pd.DataFrame(datos)
        display(df)  # ğŸ“Œ Muestra la tabla en Colab
    else:
        print("âš ï¸ No se encontraron resultados.")

# ğŸ“Œ Pregunta 1: Â¿CuÃ¡l fue el tipo de vehÃ­culo mÃ¡s vendido en 2020?
consulta1_wikidata = """
SELECT ?vehicleTypeLabel (SUM(?quantity) AS ?totalSold) WHERE {
  ?registration wdt:P31 wd:Q80730726 ;  # Instancia de inscripciÃ³n de vehÃ­culos
               wdt:P571 ?date ;          # Fecha de inscripciÃ³n
               wdt:P4003 ?vehicleType ;  # Tipo de vehÃ­culo
               wdt:P1114 ?quantity .     # Cantidad inscrita
  FILTER(YEAR(?date) = 2020)  # Filtrar solo aÃ±o 2020
  SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
}
GROUP BY ?vehicleTypeLabel
ORDER BY DESC(?totalSold)
LIMIT 1
"""
ejecutar_consulta_wikidata(consulta1_wikidata, "ğŸ“Œ Tipo de vehÃ­culo mÃ¡s vendido en 2020 (Wikidata)")

# ğŸ“Œ Pregunta 2: Â¿CuÃ¡ntos tipos diferentes de vehÃ­culos se registraron en el dataset?
consulta2_wikidata = """
SELECT (COUNT(DISTINCT ?vehicleType) AS ?totalTypes) WHERE {
  ?registration wdt:P31 wd:Q80730726 ;  # Instancia de inscripciÃ³n de vehÃ­culos
               wdt:P4003 ?vehicleType . # Tipo de vehÃ­culo
}
"""
ejecutar_consulta_wikidata(consulta2_wikidata, "ğŸ“Œ Cantidad de tipos diferentes de vehÃ­culos registrados (Wikidata)")

"""# **Fortalezas de Wikidata:**
* Disponible pÃºblicamente y colaborativo
* InformaciÃ³n mÃ¡s generalizada y accesible

# **Desventajas de Wikidata:**
* Puede haber datos incompletos o desactualizados
* No refleja datos especÃ­ficos de nuestro dataset

# **Respuesta mediante LLMs (ChatGPT, GPT-4, etc.)**

* **Pregunta:** Â¿CuÃ¡l fue el tipo de vehÃ­culo mÃ¡s vendido en 2020?

* **Respuesta:** En 2020, el tipo de vehÃ­culo mÃ¡s vendido a nivel mundial fue el automÃ³vil compacto, con el Toyota Corolla liderando las ventas con 1,134,262 unidades.

# **Fortalezas de los LLMs:**
* Accesibles para cualquier usuario
* Pueden generar explicaciones comprensibles y contexto adicional

# **Problemas en las respuestas de los LLMs:**
* No acceden a datos estructurados en tiempo real
* Respuestas basadas en estimaciones y patrones de entrenamiento
* Imprecisiones y falta de verificabilidad
"""